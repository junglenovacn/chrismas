<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä½å¤šè¾¹å½¢é£æ ¼ - å››åˆé™¢</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #2a2a3a;
            font-family: 'Microsoft YaHei', sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        #day-night-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            color: white;
            padding: 12px 25px;
            font-size: 16px;
            border-radius: 25px;
            cursor: pointer;
            z-index: 100;
            transition: all 0.3s;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        #day-night-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        #title {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 30px;
            border-radius: 20px;
            font-size: 18px;
            font-weight: bold;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>
    <div id="info">
        ğŸ›ï¸ ä½å¤šè¾¹å½¢å››åˆé™¢<br>
        æ‹–åŠ¨æ—‹è½¬ | æ»šè½®ç¼©æ”¾ | å³é”®å¹³ç§»
    </div>
    <button id="day-night-btn">ğŸŒ™ å¤œæ™šæ¨¡å¼</button>
    <div id="title">ä¼ ç»Ÿä¸­å¼å››åˆé™¢</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // ========================================
        // åœºæ™¯åˆå§‹åŒ–
        // ========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(30, 40, 30);
        camera.lookAt(0, 5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // è½¨é“æ§åˆ¶å™¨
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2.1;
        controls.minDistance = 20;
        controls.maxDistance = 100;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.3;

        // ========================================
        // æè´¨å®šä¹‰
        // ========================================
        const materials = {
            wall: new THREE.MeshLambertMaterial({ color: 0xB22222 }), // æœ±çº¢è‰²å¢™é¢
            wood: new THREE.MeshLambertMaterial({ color: 0x8B4513 }), // æœ¨è´¨çº¹ç†
            woodDark: new THREE.MeshLambertMaterial({ color: 0x654321 }), // æ·±æœ¨è‰²
            roof: new THREE.MeshLambertMaterial({ color: 0x4A4A4A }), // æ·±ç°ç“¦é¡¶
            ground: new THREE.MeshLambertMaterial({ color: 0xD2B48C }), // æµ…åœŸé»„åœ°é¢
            pillar: new THREE.MeshLambertMaterial({ color: 0x8B7355 }), // æ¸¸å»Šç«‹æŸ±
            stone: new THREE.MeshLambertMaterial({ color: 0x808080 }), // çŸ³æ
            door: new THREE.MeshLambertMaterial({ color: 0x8B0000 }), // æ·±çº¢å¤§é—¨
            treeTrunk: new THREE.MeshLambertMaterial({ color: 0x8B4513 }),
            treeLeaves: new THREE.MeshLambertMaterial({ color: 0x228B22 }),
            lantern: new THREE.MeshLambertMaterial({ color: 0xFF4500 }), // ç¯ç¬¼
            lanternGlow: new THREE.MeshBasicMaterial({ color: 0xFFA500 })
        };

        // ========================================
        // åœ°é¢
        // ========================================
        const groundGeometry = new THREE.PlaneGeometry(60, 60);
        const ground = new THREE.Mesh(groundGeometry, materials.ground);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // ========================================
        // æ­£æˆ¿ï¼ˆåŒ—æˆ¿ï¼‰
        // ========================================
        function createMainHouse(width, depth, height) {
            const group = new THREE.Group();
            
            // åŸºåº§
            const baseGeometry = new THREE.BoxGeometry(width + 2, 0.5, depth + 2);
            const base = new THREE.Mesh(baseGeometry, materials.stone);
            base.position.y = 0.25;
            base.receiveShadow = true;
            group.add(base);
            
            // å¢™ä½“
            const wallGeometry = new THREE.BoxGeometry(width, height, depth);
            const walls = new THREE.Mesh(wallGeometry, materials.wall);
            walls.position.y = height / 2 + 0.5;
            walls.castShadow = true;
            walls.receiveShadow = true;
            group.add(walls);
            
            // å±‹é¡¶
            const roofGeometry = new THREE.ConeGeometry(Math.max(width, depth) * 0.8, 4, 4);
            const roof = new THREE.Mesh(roofGeometry, materials.roof);
            roof.position.y = height + 0.5 + 2;
            roof.scale.set(1, 0.6, 1);
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            group.add(roof);
            
            // å ‚å±‹ï¼ˆä¸­é—´ï¼‰
            const centerWindowGeometry = new THREE.BoxGeometry(3, 2, 0.3);
            const centerWindow = new THREE.Mesh(centerWindowGeometry, materials.woodDark);
            centerWindow.position.set(0, height / 2 + 1, depth / 2 + 0.2);
            group.add(centerWindow);
            
            // æ¬¡é—´ï¼ˆä¸¤ä¾§ï¼‰
            const sideWindowGeometry = new THREE.BoxGeometry(2.5, 2, 0.3);
            for (let i = 0; i < 2; i++) {
                const sideWindow = new THREE.Mesh(sideWindowGeometry, materials.wood);
                sideWindow.position.set((i === 0 ? -1 : 1) * width / 3, height / 2 + 1, depth / 2 + 0.2);
                group.add(sideWindow);
            }
            
            return group;
        }

        const mainHouse = createMainHouse(14, 8, 7);
        mainHouse.position.set(0, 0, -15);
        scene.add(mainHouse);

        // ========================================
        // å¢æˆ¿ï¼ˆä¸œè¥¿ï¼‰
        // ========================================
        function createSideHouse(width, depth, height) {
            const group = new THREE.Group();
            
            // å¢™ä½“
            const wallGeometry = new THREE.BoxGeometry(width, height, depth);
            const walls = new THREE.Mesh(wallGeometry, materials.wall);
            walls.position.y = height / 2;
            walls.castShadow = true;
            walls.receiveShadow = true;
            group.add(walls);
            
            // å±‹é¡¶
            const roofGeometry = new THREE.ConeGeometry(Math.max(width, depth) * 0.7, 3, 4);
            const roof = new THREE.Mesh(roofGeometry, materials.roof);
            roof.position.y = height + 1.5;
            roof.scale.set(1, 0.6, 1);
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            group.add(roof);
            
            return group;
        }

        // ä¸œå¢æˆ¿
        const eastHouse = createSideHouse(10, 6, 5);
        eastHouse.position.set(-10, 0, -5);
        eastHouse.rotation.y = Math.PI / 2;
        scene.add(eastHouse);

        // è¥¿å¢æˆ¿
        const westHouse = createSideHouse(10, 6, 5);
        westHouse.position.set(10, 0, -5);
        westHouse.rotation.y = -Math.PI / 2;
        scene.add(westHouse);

        // ========================================
        // å€’åº§æˆ¿ï¼ˆå—æˆ¿ï¼‰
        // ========================================
        const southHouse = createSideHouse(14, 6, 5);
        southHouse.position.set(0, 0, 10);
        scene.add(southHouse);

        // ========================================
        // å¤§é—¨ï¼ˆä¸œå—è§’ï¼‰
        // ========================================
        function createGate() {
            const group = new THREE.Group();
            
            // é—¨æŸ±
            const pillarGeometry = new THREE.BoxGeometry(1, 8, 1);
            for (let i = 0; i < 2; i++) {
                const pillar = new THREE.Mesh(pillarGeometry, materials.stone);
                pillar.position.set((i === 0 ? -1 : 1) * 2, 4, 15);
                pillar.castShadow = true;
                group.add(pillar);
            }
            
            // é—¨é¡¶
            const topGeometry = new THREE.BoxGeometry(6, 1, 2);
            const top = new THREE.Mesh(topGeometry, materials.roof);
            top.position.set(0, 8, 15);
            top.castShadow = true;
            group.add(top);
            
            // é—¨æ‰‰
            const doorGeometry = new THREE.BoxGeometry(3, 5, 0.3);
            const door = new THREE.Mesh(doorGeometry, materials.door);
            door.position.set(0, 3, 15);
            door.castShadow = true;
            door.userData.isDoor = true;
            group.add(door);
            
            return group;
        }

        const gate = createGate();
        gate.position.set(0, 0, 0);
        scene.add(gate);

        // ========================================
        // æ¸¸å»Š
        // ========================================
        function createCorridor(length, width, height) {
            const group = new THREE.Group();
            
            // åœ°æ¿
            const floorGeometry = new THREE.PlaneGeometry(length, width);
            const floor = new THREE.Mesh(floorGeometry, materials.woodDark);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0.1;
            floor.receiveShadow = true;
            group.add(floor);
            
            // ç«‹æŸ±
            const pillarGeometry = new THREE.CylinderGeometry(0.3, 0.3, height, 8);
            const numPillars = Math.floor(length / 4);
            for (let i = 0; i <= numPillars; i++) {
                const pillar = new THREE.Mesh(pillarGeometry, materials.pillar);
                pillar.position.set(i * 4 - length / 2, height / 2, width / 2 - 1);
                pillar.castShadow = true;
                group.add(pillar);
            }
            
            return group;
        }

        // åŒ—ä¾§æ¸¸å»Š
        const northCorridor = createCorridor(16, 3, 3);
        northCorridor.position.set(0, 0, -12);
        scene.add(northCorridor);

        // ä¸œè¥¿æ¸¸å»Š
        const eastCorridor = createCorridor(14, 3, 3);
        eastCorridor.position.set(-8.5, 0, -4);
        eastCorridor.rotation.y = Math.PI / 2;
        scene.add(eastCorridor);

        const westCorridor = createCorridor(14, 3, 3);
        westCorridor.position.set(8.5, 0, -4);
        westCorridor.rotation.y = -Math.PI / 2;
        scene.add(westCorridor);

        // ========================================
        // å½±å£
        // ========================================
        function createScreenWall() {
            const group = new THREE.Group();
            
            // å¢™ä½“
            const wallGeometry = new THREE.BoxGeometry(6, 4, 0.5);
            const wall = new THREE.Mesh(wallGeometry, materials.wall);
            wall.position.y = 2;
            wall.castShadow = true;
            group.add(wall);
            
            // è£…é¥°å›¾æ¡ˆï¼ˆæµ®é›•æŠ½è±¡ï¼‰
            const patternGeometry = new THREE.CircleGeometry(1.5, 6);
            const patternMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
            const pattern = new THREE.Mesh(patternGeometry, patternMaterial);
            pattern.position.set(0, 2.5, 0.3);
            pattern.scale.set(1.2, 1.2, 1);
            group.add(pattern);
            
            return group;
        }

        const screenWall = createScreenWall();
        screenWall.position.set(0, 0, 12);
        scene.add(screenWall);

        // ========================================
        // åº­é™¢å…ƒç´ 
        // ========================================
        // ä¸­å¤®çŸ³å°
        const stonePlatformGeometry = new THREE.BoxGeometry(5, 1, 5);
        const stonePlatform = new THREE.Mesh(stonePlatformGeometry, materials.stone);
        stonePlatform.position.set(0, 0.5, 0);
        stonePlatform.receiveShadow = true;
        scene.add(stonePlatform);

        // èŠ±å›è£…é¥°
        const flowerPotGeometry = new THREE.CylinderGeometry(1.5, 1.8, 1, 8);
        const flowerPot = new THREE.Mesh(flowerPotGeometry, materials.wood);
        flowerPot.position.set(0, 1.5, 0);
        flowerPot.castShadow = true;
        scene.add(flowerPot);

        // ç®€åŒ–çš„èŠ±æœµ
        for (let i = 0; i < 5; i++) {
            const flowerGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const flowerColors = [0xFF69B4, 0xFFD700, 0xFF4500, 0x9370DB, 0x00CED1];
            const flowerMaterial = new THREE.MeshLambertMaterial({ 
                color: flowerColors[i % flowerColors.length] 
            });
            const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
            const angle = (i / 5) * Math.PI * 2;
            flower.position.set(
                Math.cos(angle) * 0.8,
                2.2,
                Math.sin(angle) * 0.8
            );
            flower.userData.isFlower = true;
            flower.userData.offset = angle;
            scene.add(flower);
        }

        // ========================================
        // æ ‘æœ¨ï¼ˆä½å¤šè¾¹å½¢é£æ ¼ï¼‰
        // ========================================
        function createTree(x, z) {
            const group = new THREE.Group();
            
            // æ ‘å¹²
            const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 4, 6);
            const trunk = new THREE.Mesh(trunkGeometry, materials.treeTrunk);
            trunk.position.y = 2;
            trunk.castShadow = true;
            group.add(trunk);
            
            // æ ‘å† ï¼ˆå¤šä¸ªçƒä½“ç»„åˆï¼‰
            const leafLayers = [
                { y: 4, radius: 2.5 },
                { y: 5.5, radius: 2 },
                { y: 7, radius: 1.5 }
            ];
            
            leafLayers.forEach(layer => {
                const leafGeometry = new THREE.SphereGeometry(layer.radius, 8, 8);
                const leaves = new THREE.Mesh(leafGeometry, materials.treeLeaves);
                leaves.position.y = layer.y;
                leaves.scale.y = 0.7;
                leaves.castShadow = true;
                leaves.userData.isLeaf = true;
                group.add(leaves);
            });
            
            group.position.set(x, 0, z);
            return group;
        }

        const tree1 = createTree(-18, 18);
        scene.add(tree1);

        const tree2 = createTree(18, -12);
        scene.add(tree2);

        // ========================================
        // å…‰ç…§ç³»ç»Ÿ
        // ========================================
        // ä¸»å…‰æºï¼ˆå¤ªé˜³ï¼‰- ä»è¥¿å—æ–¹
        const sunLight = new THREE.DirectionalLight(0xFFFAF0, 1.2);
        sunLight.position.set(-20, 30, 20);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 100;
        sunLight.shadow.camera.left = -40;
        sunLight.shadow.camera.right = 40;
        sunLight.shadow.camera.top = 40;
        sunLight.shadow.camera.bottom = -40;
        scene.add(sunLight);

        // ç¯å¢ƒå…‰
        const ambientLight = new THREE.AmbientLight(0xFFF8DC, 0.5);
        scene.add(ambientLight);

        // ========================================
        // å¤œæ™šæ¨¡å¼
        // ========================================
        let isNight = false;
        const lanterns = [];

        function createLantern(x, y, z) {
            const group = new THREE.Group();
            
            // ç¯ç¬¼ä¸»ä½“
            const lanternGeometry = new THREE.SphereGeometry(0.6, 8, 8);
            const lantern = new THREE.Mesh(lanternGeometry, materials.lantern);
            lantern.scale.y = 1.3;
            lantern.castShadow = true;
            group.add(lantern);
            
            // å‘å…‰æ•ˆæœ
            const glowGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const glow = new THREE.Mesh(glowGeometry, materials.lanternGlow);
            glow.position.y = 0;
            glow.visible = false;
            group.add(glow);
            
            // ç‚¹å…‰æºï¼ˆä»…å¤œæ™šå¼€å¯ï¼‰
            const pointLight = new THREE.PointLight(0xFFA500, 0, 8);
            group.add(pointLight);
            
            group.position.set(x, y, z);
            group.userData.glow = glow;
            group.userData.light = pointLight;
            
            return group;
        }

        // åœ¨æŸ±å­ä¸Šæ·»åŠ ç¯ç¬¼
        const lanternPositions = [
            [-10, 3, -12], [10, 3, -12],
            [-10, 3, 5], [10, 3, 5],
            [-2, 3, 15], [2, 3, 15]
        ];

        lanternPositions.forEach(pos => {
            const lantern = createLantern(...pos);
            scene.add(lantern);
            lanterns.push(lantern);
        });

        // æ˜¼å¤œåˆ‡æ¢
        const dayNightBtn = document.getElementById('day-night-btn');
        dayNightBtn.addEventListener('click', () => {
            isNight = !isNight;
            toggleDayNight();
        });

        function toggleDayNight() {
            if (isNight) {
                // å¤œæ™šæ¨¡å¼
                scene.background = new THREE.Color(0x0a0a1a);
                scene.fog = new THREE.Fog(0x0a0a1a, 30, 150);
                sunLight.intensity = 0.1;
                sunLight.color.setHex(0x6666FF);
                ambientLight.intensity = 0.15;
                ambientLight.color.setHex(0x4466AA);
                
                // å¼€å¯ç¯ç¬¼
                lanterns.forEach(lantern => {
                    lantern.userData.light.intensity = 1.5;
                    lantern.userData.glow.visible = true;
                });
                
                dayNightBtn.textContent = 'â˜€ï¸ ç™½å¤©æ¨¡å¼';
            } else {
                // ç™½å¤©æ¨¡å¼
                scene.background = new THREE.Color(0x87CEEB);
                scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
                sunLight.intensity = 1.2;
                sunLight.color.setHex(0xFFFAF0);
                ambientLight.intensity = 0.5;
                ambientLight.color.setHex(0xFFF8DC);
                
                // å…³é—­ç¯ç¬¼
                lanterns.forEach(lantern => {
                    lantern.userData.light.intensity = 0;
                    lantern.userData.glow.visible = false;
                });
                
                dayNightBtn.textContent = 'ğŸŒ™ å¤œæ™šæ¨¡å¼';
            }
        }

        // ========================================
        // äº¤äº’
        // ========================================
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('click', onMouseClick);

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            if (intersects.length > 0) {
                const object = intersects[0].object;
                if (object.userData.isDoor) {
                    // é—¨å¼€åˆåŠ¨ç”»
                    const door = object;
                    const isOpen = door.scale.x > 0.5;
                    
                    // ç®€å•çš„æ—‹è½¬åŠ¨ç”»
                    let rotation = 0;
                    const animateDoor = () => {
                        if (isOpen) {
                            rotation -= 0.1;
                            if (rotation < -Math.PI / 2) {
                                door.rotation.y = -Math.PI / 2;
                                door.scale.x = 0.1;
                            } else {
                                door.rotation.y = rotation;
                                requestAnimationFrame(animateDoor);
                            }
                        } else {
                            door.rotation.y = 0;
                            door.scale.x = 1;
                        }
                    };
                    animateDoor();
                }
            }
        }

        // ========================================
        // åŠ¨ç”»å¾ªç¯
        // ========================================
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // æ ‘å¶æ‘†åŠ¨
            scene.traverse(object => {
                if (object.userData.isLeaf) {
                    object.rotation.x = Math.sin(time + object.position.y) * 0.1;
                    object.rotation.z = Math.cos(time + object.position.y) * 0.1;
                }
            });

            // èŠ±æœµè½»å¾®æ‘†åŠ¨
            scene.traverse(object => {
                if (object.userData.isFlower) {
                    const angle = object.userData.offset;
                    object.position.y = 2.2 + Math.sin(time * 2 + angle) * 0.05;
                }
            });

            // ç¯ç¬¼æ‘‡æ‘†
            if (isNight) {
                lanterns.forEach((lantern, i) => {
                    lantern.rotation.y = Math.sin(time + i) * 0.1;
                });
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // ========================================
        // çª—å£å¤§å°è°ƒæ•´
        // ========================================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // å¯åŠ¨åŠ¨ç”»
        animate();
    </script>
</body>
</html>
